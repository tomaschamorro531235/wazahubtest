local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

local lp = game.Players.LocalPlayer
local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local Camera = workspace.CurrentCamera

local function generarNombreFalso()
	local palabras = {"Xeno", "Nova", "Ghost", "Delta", "Hex", "Neo", "Zero", "Void", "Pixel", "Rift"}
	local sufijo = math.random(100, 999)
	return palabras[math.random(1, #palabras)] .. sufijo
end

local function ocultarNombreEnGui(nombreOriginal, nombreFalso)
	local function filtrarTexto(gui)
		for _, obj in pairs(gui:GetDescendants()) do
			if obj:IsA("TextLabel") or obj:IsA("TextButton") then
				if string.find(obj.Text, nombreOriginal) then
					obj.Text = obj.Text:gsub(nombreOriginal, nombreFalso)
				end
			end
		end
	end

	return task.spawn(function()
		while true do
			pcall(function()
				filtrarTexto(game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"))
				filtrarTexto(game:GetService("CoreGui"))
			end)
			task.wait(0.5)
		end
	end)
end

local floatEnabled, godEnabled, walkEnabled, flyEnabled, noclipEnabled = false, false, false, false, false
local floatLoop, godConnection, wsConnection, noclipConn, flyConn, antiTPConnection, movementConnection = nil, nil, nil, nil, nil, nil, nil
local walkSpeedValue, flySpeed, height, speed, waitTime = 32, 32, 10, 0.2, 0.01
local lastPos = nil
local originalName = lp.Name
local nombreFalso_UI = generarNombreFalso()
local limpiezaTask = nil
local infiniteJumpEnabled = false
local jumpConnection
local autoRejoinEnabled = false
local hookRejoin = nil
local guiDetectionConn = nil
local antiBoogieConn = nil
local defaultFOV = Camera.FieldOfView
local serverHopRunning = false
local serverHopThread = nil
local lp = game.Players.LocalPlayer
local username = lp.Name
local baseText = string.lower(username .. "'s base")
local miBaseDetectada = nil
local autopilotConnection = nil
local correctedSpeed = 45
local normalFOV = workspace.CurrentCamera.FieldOfView
local originalEffects = {}
local movementConnection = nil

local originalEffects = {}
local function saveOriginalEffects()
	originalEffects = {}
	for _, effect in pairs(Lighting:GetChildren()) do
		if effect:IsA("ColorCorrectionEffect") or effect:IsA("BlurEffect") then
			table.insert(originalEffects, effect:Clone())
		end
	end
end

local function restoreOriginalEffects()
	for _, v in pairs(Lighting:GetChildren()) do
		if v:IsA("ColorCorrectionEffect") or v:IsA("BlurEffect") then
			v:Destroy()
		end
	end
	for _, effect in pairs(originalEffects) do
		effect.Parent = Lighting
	end
end

local function getCameraInputDirection()
	local cam = workspace.CurrentCamera
	local dir = Vector3.zero
	if UIS:IsKeyDown(Enum.KeyCode.W) then dir += cam.CFrame.LookVector end
	if UIS:IsKeyDown(Enum.KeyCode.S) then dir -= cam.CFrame.LookVector end
	if UIS:IsKeyDown(Enum.KeyCode.D) then dir += cam.CFrame.RightVector end
	if UIS:IsKeyDown(Enum.KeyCode.A) then dir -= cam.CFrame.RightVector end
	return dir.Magnitude > 0 and Vector3.new(dir.X, 0, dir.Z).Unit or Vector3.zero
end

local function createBoxESP(player)
	if player == lp then return end
	local char = player.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") then return end
	if not char:FindFirstChild("BoxESP") then
		local box = Instance.new("BoxHandleAdornment")
		box.Name = "BoxESP"
		box.Adornee = char:FindFirstChild("HumanoidRootPart")
		box.AlwaysOnTop = true
		box.ZIndex = 10
		box.Size = Vector3.new(3, 5, 1)
		box.Color3 = Color3.fromRGB(255, 255, 255)
		box.Transparency = 0.6
		box.Parent = char
	end
end

task.spawn(function()
	while true do
		if boxESPEnabled then
			for _, player in pairs(game.Players:GetPlayers()) do
				createBoxESP(player)
			end
		else
			for _, player in pairs(game.Players:GetPlayers()) do
				local char = player.Character
				if char and char:FindFirstChild("BoxESP") then
					char.BoxESP:Destroy()
				end
			end
		end
		task.wait(1)
	end
end)

local validPositions = {
	Vector3.new(-517.13, -5.10, 220.66),
	Vector3.new(-517.48, -5.10, 113.48),
	Vector3.new(-517.52, -5.10,   6.59),
	Vector3.new(-517.39, -5.10, -100.83),
	Vector3.new(-301.08, -5.04, -100.64),
	Vector3.new(-301.60, -5.10,    6.33),
	Vector3.new(-302.36, -5.10,  221.03),
	Vector3.new(-301.60, -5.10, 113.76)
}

local function isCloseToAnyValidPosition(pos)
	for _, valid in pairs(validPositions) do
		if (pos - valid).Magnitude <= 10 then
			return true
		end
	end
	return false
end

local function updateAllTimerESPs()
	for _, label in pairs(workspace:GetDescendants()) do
		if label:IsA("TextLabel") and label:IsDescendantOf(workspace) then
			local text = label.Text
			if string.match(text, "^%d+s$") then
				local parentGui = label.Parent
				local adornee = parentGui and (parentGui.Adornee or parentGui.Parent)

				if adornee and adornee:IsA("BasePart") then
					local pos = adornee.Position
					if isCloseToAnyValidPosition(pos) then
						if not adornee:FindFirstChild("UniversalTimerESP") then
							local esp = Instance.new("BillboardGui")
							esp.Name = "UniversalTimerESP"
							esp.Size = UDim2.new(0, 100, 0, 40)
							esp.AlwaysOnTop = true
							esp.Adornee = adornee
							esp.StudsOffset = Vector3.new(0, 2.5, 0)

							local textLabel = Instance.new("TextLabel")
							textLabel.Name = "ESPText"
							textLabel.Size = UDim2.new(1, 0, 1, 0)
							textLabel.BackgroundTransparency = 1
							textLabel.TextScaled = true
							textLabel.Font = Enum.Font.FredokaOne
							textLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
							textLabel.TextStrokeTransparency = 0
							textLabel.Text = text
							textLabel.Parent = esp

							esp.Parent = adornee
						else
							local gui = adornee:FindFirstChild("UniversalTimerESP")
							if gui and gui:FindFirstChild("ESPText") then
								gui.ESPText.Text = text
							end
						end
					else
						if adornee:FindFirstChild("UniversalTimerESP") then
							adornee.UniversalTimerESP:Destroy()
						end
					end
				end
			end
		end
	end
end

task.spawn(function()
	while true do
		if timerESPEnabled then
			pcall(updateAllTimerESPs)
		else
			for _, obj in pairs(workspace:GetDescendants()) do
				if obj.Name == "UniversalTimerESP" then
					obj:Destroy()
				end
			end
		end
		task.wait(0.4)
	end
end)

local Window = Rayfield:CreateWindow({
	Name = "| Hub Waza |",
	LoadingTitle = "Loading...",
	LoadingSubtitle = "by waza",
	ConfigurationSaving = {
		Enabled = true,
		FolderName = "WazaGodFloatSpeed",
		FileName = "Settings"
	},
	KeySystem = false
})

local function detectarBasePorTexto()
	for _, label in ipairs(workspace:GetDescendants()) do
		if label:IsA("TextLabel") then
			local textLower = string.lower(label.Text)
			if textLower == baseText then
				local part = label:FindFirstAncestorWhichIsA("BasePart")
				if part then
					miBaseDetectada = part.Position
					return true
				end
			end
		end
	end
	return false
end

local function volarAHasta(pos)
	local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	if autopilotConnection then autopilotConnection:Disconnect() end

	autopilotConnection = game:GetService("RunService").Heartbeat:Connect(function()
		if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
			autopilotConnection:Disconnect()
			return
		end

		local currentPos = hrp.Position
		local dir = (pos - currentPos)
		local dist = dir.Magnitude

		if dist < 2 then
			autopilotConnection:Disconnect()
			Rayfield:Notify({
				Title = "autopilot",
				Content = "You arrived at your base",
				Duration = 3
			})
			return
		end

		local move = dir.Unit * math.min(dist, 0.4)
		local forward = hrp.Position + hrp.CFrame.LookVector
		hrp.Velocity = Vector3.zero
		hrp.CFrame = CFrame.new(currentPos + move, forward)
	end)
end

local function irAMiBaseConNombre()
	local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	if not miBaseDetectada then
		if detectarBasePorTexto() then
			Rayfield:Notify({
				Title = "Base found",
				Content = "base with your name detected. Flying...",
				Duration = 4
			})
		else
			Rayfield:Notify({
				Title = "Your base was not detected",
				Content = "No database was found with your name.",
				Duration = 4
			})
			return
		end
	end

	volarAHasta(miBaseDetectada + Vector3.new(0, 5, 0))
end

-- Guardar efectos visuales originales
local function saveOriginalEffects()
	originalEffects = {}
	for _, effect in pairs(Lighting:GetChildren()) do
		if effect:IsA("ColorCorrectionEffect") or effect:IsA("BlurEffect") then
			table.insert(originalEffects, effect:Clone())
		end
	end
end

-- Restaurar efectos originales
local function restoreOriginalEffects()
	for _, effect in pairs(Lighting:GetChildren()) do
		if effect:IsA("ColorCorrectionEffect") or effect:IsA("BlurEffect") then
			effect:Destroy()
		end
	end
	for _, original in ipairs(originalEffects) do
		original.Parent = Lighting
	end
end

-- Obtener dirección según la cámara (PC)
local function getCameraInputDirection()
	local dir = Vector3.zero
	if UIS:IsKeyDown(Enum.KeyCode.W) then dir += Camera.CFrame.LookVector end
	if UIS:IsKeyDown(Enum.KeyCode.S) then dir -= Camera.CFrame.LookVector end
	if UIS:IsKeyDown(Enum.KeyCode.D) then dir += Camera.CFrame.RightVector end
	if UIS:IsKeyDown(Enum.KeyCode.A) then dir -= Camera.CFrame.RightVector end
	return Vector3.new(dir.X, 0, dir.Z).Unit
end

local Tab_Movimiento = Window:CreateTab("movements")
local Tab_Proteccion = Window:CreateTab("Protections")
local Tab_Ajustes = Window:CreateTab("Settings")
local Tab_ESP = Window:CreateTab("ESP")
local Tab_Extras = Window:CreateTab("Extras")

Tab_Movimiento:CreateToggle({
    Name = "Fly",
    Flag = "FlyToggle",
    CurrentValue = false,
    Callback = function(state)
        if state and (not godEnabled) then
            Rayfield:Notify({
                Title = "Fly",
                Content = "Please enable Godmode and Anti TP first to use Fly.",
                Duration = 3
            })
            Rayfield.Flags["FlyToggle"]:Set(false)
            return
        end

        flyEnabled = state
        if flyEnabled then
            local char = lp.Character or lp.CharacterAdded:Wait()
            local hrp = char:WaitForChild("HumanoidRootPart")
            local hum = char:WaitForChild("Humanoid")

            Rayfield:Notify({
                Title = "Fly",
                Content = "Fly activated uses 40 speed maximum on mobile.",
                Duration = 3
            })

            flyConn = RS.RenderStepped:Connect(function()
                if not (char and char.Parent) then return end

                local cam = workspace.CurrentCamera
                local camLook = cam.CFrame.LookVector
                local moveVec = Vector3.zero

                if hum.MoveDirection.Magnitude > 0 then
                    moveVec = camLook.Unit * flySpeed
                end

                if UIS:IsKeyDown(Enum.KeyCode.Space) then
                    moveVec = moveVec + Vector3.new(0, flySpeed, 0)
                elseif UIS:IsKeyDown(Enum.KeyCode.LeftControl) then
                    moveVec = moveVec - Vector3.new(0, flySpeed, 0)
                end

                hrp.Velocity = moveVec
            end)
        else
            if flyConn then flyConn:Disconnect() flyConn = nil end
            local char = lp.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.Velocity = Vector3.zero
            end
        end
    end
})

Tab_Movimiento:CreateToggle({
	Name = "WalkSpeed",
	Flag = "WalkSpeedToggle",
	CurrentValue = false,
	Callback = function(enabled)
		walkEnabled = enabled

		if movementConnection then
			movementConnection:Disconnect()
			movementConnection = nil
		end

		if enabled then
			local isMobile = UIS.TouchEnabled and not UIS.KeyboardEnabled
			movementConnection = RS.RenderStepped:Connect(function()
				local char = lp.Character
				if not char then return end

				local hrp = char:FindFirstChild("HumanoidRootPart")
				local hum = char:FindFirstChildOfClass("Humanoid")
				if not hrp or not hum then return end

				hum.PlatformStand = false
				hum:ChangeState(Enum.HumanoidStateType.Running)

				local horizontalVel = Vector3.zero

				if isMobile then
					local moveDir = hum.MoveDirection
					if moveDir.Magnitude > 0.1 then
						local dir = Vector3.new(moveDir.X, 0, moveDir.Z).Unit
						horizontalVel = dir * walkSpeedValue
					end
				else
					local moveVec = Vector3.zero
					if UIS:IsKeyDown(Enum.KeyCode.W) then moveVec += Camera.CFrame.LookVector end
					if UIS:IsKeyDown(Enum.KeyCode.S) then moveVec -= Camera.CFrame.LookVector end
					if UIS:IsKeyDown(Enum.KeyCode.D) then moveVec += Camera.CFrame.RightVector end
					if UIS:IsKeyDown(Enum.KeyCode.A) then moveVec -= Camera.CFrame.RightVector end

					if moveVec.Magnitude > 0 then
						local dir = Vector3.new(moveVec.X, 0, moveVec.Z).Unit
						horizontalVel = dir * walkSpeedValue
					end
				end

				local currentY = hrp.AssemblyLinearVelocity.Y
				local clampedY = math.clamp(currentY, -50, 50)
				local verticalVel = Vector3.new(0, clampedY, 0)

				hrp.AssemblyLinearVelocity = horizontalVel + verticalVel
			end)

			lp.CharacterAdded:Connect(function()
				if walkEnabled then
					task.wait(1)
					Rayfield.Flags["WalkSpeedToggle"]:Set(true)
				end
			end)
		end
	end
})

Tab_Movimiento:CreateToggle({
    Name = "Noclip",
    Flag = "NoclipToggle",
    CurrentValue = false,
    Callback = function(enabled)
        noclipEnabled = enabled
        if noclipEnabled then
            local function applyNoclip()
                local char = lp.Character or lp.CharacterAdded:Wait()
                noclipConn = RS.RenderStepped:Connect(function()
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end)
            end

            applyNoclip()
            lp.CharacterAdded:Connect(function()
                if noclipEnabled then task.wait(1); applyNoclip() end
            end)
        else
            if noclipConn then noclipConn:Disconnect() end
            local char = lp.Character
            if char then
                for _, part in pairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
})

Tab_Movimiento:CreateToggle({
	Name = "Float",
	Flag = "FloatToggle",
	CurrentValue = false,
	Callback = function(state)
		if state and not godEnabled then
			Rayfield:Notify({
				Title = "Godmode required",
				Content = "Please activate Godmode first to use Float.",
				Duration = 3
			})
			Rayfield.Flags["FloatToggle"]:Set(false)
			return
		end

		floatEnabled = state
		if floatEnabled then
			local function floatCycle()
				local char = lp.Character or lp.CharacterAdded:Wait()
				local hrp = char:WaitForChild("HumanoidRootPart")
				while floatEnabled and char and hrp do
					for i = 1, height do
						if not floatEnabled then return end
						hrp.CFrame = hrp.CFrame + Vector3.new(0, speed, 0)
						task.wait(waitTime)
					end
					for i = height, 1, -1 do
						if not floatEnabled then return end
						local ray = Workspace:Raycast(hrp.Position, Vector3.new(0, -3, 0), RaycastParams.new())
						if ray and hrp.Position.Y - ray.Position.Y < 3 then break end
						hrp.CFrame = hrp.CFrame - Vector3.new(0, speed, 0)
						task.wait(waitTime)
					end
				end
			end
			floatLoop = coroutine.create(floatCycle)
			coroutine.resume(floatLoop)
		else
			floatLoop = nil
		end
	end
})

Tab_Movimiento:CreateToggle({
	Name = "Infinite Jump",
	Flag = "InfiniteJumpToggle",
	CurrentValue = false,
	Callback = function(enabled)
		if enabled and not godEnabled then
			Rayfield:Notify({
				Title = "Godmode required",
				Content = "Activate Godmode first to use Infinite Jump.",
				Duration = 3
			})
			Rayfield.Flags["InfiniteJumpToggle"]:Set(false)
			return
		end

		infiniteJumpEnabled = enabled

		if jumpConnection then jumpConnection:Disconnect() jumpConnection = nil end

		if enabled then
			jumpConnection = UIS.JumpRequest:Connect(function()
				local char = lp.Character
				if char and char:FindFirstChildOfClass("Humanoid") then
					char:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end)

			lp.CharacterAdded:Connect(function()
				if infiniteJumpEnabled then
					task.wait(1)
					if jumpConnection then jumpConnection:Disconnect() end
					jumpConnection = UIS.JumpRequest:Connect(function()
						local char = lp.Character
						if char and char:FindFirstChildOfClass("Humanoid") then
							char:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
						end
					end)
				end
			end)
		end
	end
})

Tab_Ajustes:CreateKeybind({
	Name = "Key to activate Fly",
	CurrentKeybind = "F",
	HoldToInteract = false,
	Callback = function()
		if not godEnabled then
			Rayfield:Notify({
				Title = "Fly Requirements",
				Content = "Please enable Godmode first to use Fly.",
				Duration = 3
			})
			return
		end

		local toggle = not flyEnabled
		Rayfield:Notify({
			Title = "Fly",
			Content = toggle and "Actived" or "Disabled",
			Duration = 2
		})
		Rayfield.Flags["FlyToggle"]:Set(toggle)
	end
})

Tab_Ajustes:CreateKeybind({
    Name = "Key to activate WalkSpeed",
    CurrentKeybind = "G",
    HoldToInteract = false,
    Callback = function()
        local toggle = not walkEnabled
        Rayfield:Notify({Title = "WalkSpeed", Content = toggle and "Actived" or "Disabled", Duration = 2})
        Rayfield.Flags["WalkSpeedToggle"]:Set(toggle)
    end
})

Tab_Ajustes:CreateKeybind({
	Name = "Key to activate Float",
	CurrentKeybind = "H",
	HoldToInteract = false,
	Callback = function()
		if not godEnabled then
			Rayfield:Notify({
				Title = "Godmode required",
				Content = "Please activate Godmode first to use Float.",
				Duration = 3
			})
			return
		end

		local toggle = not floatEnabled
		Rayfield:Notify({
			Title = "Float",
			Content = toggle and "Actived" or "Disabled",
			Duration = 2
		})
		Rayfield.Flags["FloatToggle"]:Set(toggle)
	end
})

Tab_Ajustes:CreateKeybind({
    Name = "Key to activate Noclip",
    CurrentKeybind = "J",
    HoldToInteract = false,
    Callback = function()
        local toggle = not noclipEnabled
        Rayfield:Notify({Title = "Noclip", Content = toggle and "Actived" or "Disabled", Duration = 2})
        Rayfield.Flags["NoclipToggle"]:Set(toggle)
    end
})

Tab_Ajustes:CreateKeybind({
	Name = "Key to activate Infinite Jump",
	CurrentKeybind = "Y",
	HoldToInteract = false,
	Callback = function()
		if not godEnabled then
			Rayfield:Notify({
				Title = "Godmode requerido",
				Content = "Activate Godmode first to use Infinite Jump.",
				Duration = 3
			})
			return
		end

		local toggle = not infiniteJumpEnabled
		Rayfield:Notify({
			Title = "Infinite Jump",
			Content = toggle and "Actived" or "Disabled",
			Duration = 2
		})
		Rayfield.Flags["InfiniteJumpToggle"]:Set(toggle)
	end
})

Tab_Proteccion:CreateToggle({
    Name = "Godmode",
    CurrentValue = false,
    Callback = function(value)
        godEnabled = value
        if godEnabled then
            local function applyGod()
                local char = lp.Character or lp.CharacterAdded:Wait()
                local hum = char:WaitForChild("Humanoid")
                if hum then
                    hum.Health = 100
                    if godConnection then godConnection:Disconnect() end
                    godConnection = hum:GetPropertyChangedSignal("Health"):Connect(function()
                        if godEnabled and hum.Health < 100 then
                            hum.Health = 100
                        end
                    end)
                end
            end
            lp.CharacterAdded:Connect(function() if godEnabled then applyGod() end end)
            applyGod()
        else
            if godConnection then godConnection:Disconnect() godConnection = nil end
        end
    end
})

Tab_Proteccion:CreateToggle({
    Name = "Anti TP",
    CurrentValue = false,
    Callback = function(enabled)
        if antiTPConnection then antiTPConnection:Disconnect() end
        if enabled then
            antiTPConnection = RS.RenderStepped:Connect(function()
                local char = lp.Character
                if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChildOfClass("Humanoid") then
                    local hrp = char.HumanoidRootPart
                    local hum = char:FindFirstChildOfClass("Humanoid")
                    if hum:GetState() ~= Enum.HumanoidStateType.Dead then
                        if lastPos and (hrp.Position - lastPos).Magnitude > 20 then
                            hrp.CFrame = CFrame.new(lastPos)
                        else
                            lastPos = hrp.Position
                        end
                    end
                end
            end)
        else
            lastPos = nil
        end
    end
})

Tab_Proteccion:CreateToggle({
	Name = "Anti Bee Launcher",
	CurrentValue = false,
	Callback = function(enabled)
		if movementConnection then
			movementConnection:Disconnect()
			movementConnection = nil
		end

		if enabled then
			saveOriginalEffects()

			Rayfield:Notify({
				Title = "Protection Activated",
				Content = "The Anti Bee Launcher feature has been successfully disabled.",
				Duration = 4
			})

			movementConnection = RS.RenderStepped:Connect(function()
				local char = lp.Character
				if not char then return end

				local hrp = char:FindFirstChild("HumanoidRootPart")
				local hum = char:FindFirstChildOfClass("Humanoid")
				local cam = workspace.CurrentCamera
				if not hrp or not hum or not cam then return end

				-- Eliminar efectos visuales
				for _, v in pairs(Lighting:GetChildren()) do
					if v:IsA("ColorCorrectionEffect") or v:IsA("BlurEffect") then
						v:Destroy()
					end
				end

				-- Restaurar FOV
				if cam.FieldOfView ~= normalFOV then
					cam.FieldOfView = normalFOV
				end

				-- Movimiento corregido
				local inputDir = getCameraInputDirection()
				local vel = hrp.AssemblyLinearVelocity

				if inputDir ~= Vector3.zero then
					local dot = vel.Magnitude > 0 and vel.Unit:Dot(inputDir) or 1

					if dot < -0.3 then
						hum:Move(Vector3.zero, true)
						hrp.AssemblyLinearVelocity = inputDir * correctedSpeed
					else
						hrp.AssemblyLinearVelocity = inputDir * correctedSpeed
					end
				else
					hrp.AssemblyLinearVelocity = Vector3.new(0, vel.Y, 0)
				end
			end)
		else
			-- Restaurar todo
			if movementConnection then
				movementConnection:Disconnect()
				movementConnection = nil
			end

			restoreOriginalEffects()
			if Camera then Camera.FieldOfView = normalFOV end

			Rayfield:Notify({
				Title = "Protection Disabled",
				Content = "Screen restored successfully.",
				Duration = 3
			})
		end
	end
})

Tab_Proteccion:CreateToggle({
	Name = "Auto Rejoin if Kick",
	CurrentValue = false,
	Callback = function(enabled)
		autoRejoinEnabled = enabled

		local TeleportService = game:GetService("TeleportService")
		local Players = game:GetService("Players")
		local player = Players.LocalPlayer

		if not enabled then
			if hookRejoin then
				setreadonly(getrawmetatable(game), false)
				getrawmetatable(game).__namecall = hookRejoin
				setreadonly(getrawmetatable(game), true)
				hookRejoin = nil
			end

			if guiDetectionConn then
				guiDetectionConn:Disconnect()
				guiDetectionConn = nil
			end

			Rayfield:Notify({
				Title = "Auto Rejoin Disabled",
				Content = "Kick and error protection disabled.",
				Duration = 3
			})
			return
		end

		local mt = getrawmetatable(game)
		local oldNamecall = mt.__namecall
		setreadonly(mt, false)

		hookRejoin = newcclosure(function(self, ...)
			local method = getnamecallmethod()
			local args = { ... }

			if tostring(self) == "Kick" or method == "kick" then
				task.delay(0.25, function()
					TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
				end)
				return nil
			end

			return oldNamecall(self, unpack(args))
		end)

		mt.__namecall = hookRejoin
		setreadonly(mt, true)

		guiDetectionConn = game.CoreGui.ChildAdded:Connect(function(child)
			if child:IsA("ScreenGui") and (child:FindFirstChildWhichIsA("TextLabel", true) or child:FindFirstChildWhichIsA("ImageLabel", true)) then
				if string.lower(child.Name):find("error") or child.Name:find("Message") then
					task.wait(0.5)
					pcall(function()
						TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
					end)
				end
			end
		end)

		Rayfield:Notify({
			Title = "Auto Rejoin Actived",
			Content = "Active kick and visual error protection.",
			Duration = 4
		})
	end
})

local antiBoogieConn = nil
local defaultFOV = Camera.FieldOfView

local antiBoogieConn = nil
local defaultFOV = Camera.FieldOfView

Tab_Proteccion:CreateToggle({
	Name = "Anti Boogie Bomb",
	CurrentValue = false,
	Callback = function(enabled)
		if antiBoogieConn then
			antiBoogieConn:Disconnect()
			antiBoogieConn = nil
		end
		if antiBoogieTask then
			task.cancel(antiBoogieTask)
			antiBoogieTask = nil
		end

		if enabled then
			Rayfield:Notify({
				Title = "Anti Boogie Bomb",
				Content = "Boogie Bomb Bypassed.",
				Duration = 4
			})

			-- Animación y zoom en RenderStepped (ligero)
			antiBoogieConn = RS.RenderStepped:Connect(function()
				local char = lp.Character
				local hum = char and char:FindFirstChildOfClass("Humanoid")
				if hum then
					for _, track in pairs(hum:GetPlayingAnimationTracks()) do
						local animName = string.lower(track.Name)
						local animId = string.lower((track.Animation and track.Animation.AnimationId) or "")
						if animName:find("dance") or animName:find("boogie") or animId:find("dance") or animId:find("boogie") then
							track:Stop()
						end
					end
				end

				if math.abs(Camera.FieldOfView - defaultFOV) > 0.1 then
					Camera.FieldOfView = defaultFOV
				end
			end)

			-- Efectos visuales y sonidos menos frecuentes (cada 0.5s)
			antiBoogieTask = task.spawn(function()
				while true do
					task.wait(0.5)

					for _, effect in pairs(Lighting:GetChildren()) do
						if effect:IsA("ColorCorrectionEffect") or effect:IsA("BlurEffect") then
							if effect.TintColor == Color3.new(1,1,1) or effect.Name:lower():find("boogie") then
								effect:Destroy()
							end
						end
					end

					for _, s in pairs(workspace:GetDescendants()) do
						if s:IsA("Sound") then
							local sid = string.lower(s.SoundId)
							local name = string.lower(s.Name)
							if sid:find("boogie") or sid:find("dance") or name:find("boogie") or name:find("dance") then
								s:Destroy()
							end
						end
					end
				end
			end)
		else
			if antiBoogieConn then antiBoogieConn:Disconnect() antiBoogieConn = nil end
			if antiBoogieTask then task.cancel(antiBoogieTask) antiBoogieTask = nil end

			Rayfield:Notify({
				Title = "Anti Boogie Bomb",
				Content = "Deactivated and released resources.",
				Duration = 3
			})
		end
	end
})

Tab_Proteccion:CreateToggle({
	Name = "Anti Trap (Forzado real)",
	CurrentValue = false,
	Callback = function(enabled)
		if trapBypassConn then
			trapBypassConn:Disconnect()
			trapBypassConn = nil
		end

		if enabled then
			Rayfield:Notify({
				Title = "Anti Trap",
				Content = "Sistema de movimiento forzado activado.",
				Duration = 3
			})

			trapBypassConn = RS.RenderStepped:Connect(function()
				local char = lp.Character
				if not char then return end

				local hum = char:FindFirstChildOfClass("Humanoid")
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if not hum or not hrp then return end

				-- 🔓 Desactivar restricciones básicas
				hum.PlatformStand = false
				hrp.Anchored = false
				hum:ChangeState(Enum.HumanoidStateType.Running)

				-- 🧠 Movimiento manual por WASD o móvil
				local moveVec = hum.MoveDirection
				if moveVec.Magnitude > 0.1 then
					local dir = Vector3.new(moveVec.X, 0, moveVec.Z).Unit
					local currentY = hrp.AssemblyLinearVelocity.Y
					local vertical = Vector3.new(0, math.clamp(currentY, -50, 50), 0)

					-- 💨 Aplicar movimiento forzado
					hrp.AssemblyLinearVelocity = dir * (walkSpeedValue or 32) + vertical
				end
			end)
		else
			if trapBypassConn then
				trapBypassConn:Disconnect()
				trapBypassConn = nil
			end
			Rayfield:Notify({
				Title = "Anti Trap",
				Content = "Desactivado.",
				Duration = 2
			})
		end
	end
})

Tab_Ajustes:CreateSlider({
    Name = "Fly Speed",
    Range = {32, 55},
    Increment = 1,
    CurrentValue = flySpeed,
    Callback = function(v) flySpeed = v end
})

Tab_Ajustes:CreateSlider({
    Name = "WalkSpeed",
    Range = {32, 50},
    Increment = 1,
    CurrentValue = walkSpeedValue,
    Callback = function(v)
        walkSpeedValue = v
        if walkEnabled then
            local char = lp.Character or lp.CharacterAdded:Wait()
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then hum.WalkSpeed = walkSpeedValue end
        end
    end
})

Tab_Ajustes:CreateSlider({
    Name = "Maximum float height",
    Range = {5, 25},
    Increment = 1,
    CurrentValue = height,
    Callback = function(v) height = v end
})

Tab_Ajustes:CreateSlider({
    Name = "Upload/download speed (Float)",
    Range = {0.05, 1},
    Increment = 0.05,
    CurrentValue = speed,
    Callback = function(v) speed = v end
})

Tab_ESP:CreateToggle({
	Name = "Player Esp",
	CurrentValue = false,
	Callback = function(v)
		boxESPEnabled = v
	end
})

Tab_ESP:CreateToggle({
	Name = "ESP Timer",
	CurrentValue = false,
	Callback = function(v)
		timerESPEnabled = v
	end
})

Tab_Extras:CreateToggle({
	Name = "Fake Name",
	CurrentValue = false,
	Callback = function(enabled)
		if enabled then
			Rayfield:Notify({
				Title = "Modo Interfaz Limpia",
				Content = "Replacing your name with: " .. nombreFalso_UI,
				Duration = 4
			})

			limpiezaTask = ocultarNombreEnGui(originalName, nombreFalso_UI)
		else
			if limpiezaTask then
				task.cancel(limpiezaTask)
				limpiezaTask = nil
			end

			Rayfield:Notify({
				Title = "Nombre Restaurado",
				Content = "Your name is no longer leaked on interfaces.",
				Duration = 3
			})
		end
	end
})

Tab_Extras:CreateButton({
	Name = "Rejoin",
	Callback = function()
		local TeleportService = game:GetService("TeleportService")
		local Players = game:GetService("Players")
		local player = Players.LocalPlayer
		TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
	end
})

Tab_Extras:CreateToggle({
	Name = "ServerHop",
	CurrentValue = false,
	Callback = function(enabled)
		serverHopRunning = enabled

		if enabled then
			Rayfield:Notify({
				Title = "ServerHop",
				Content = "Looking for new server...",
				Duration = 3
			})

			serverHopThread = task.spawn(function()
				local AllIDs = {}
				local foundAnything = ""
				local actualHour = os.date("!*t").hour
				local Deleted = false
				local S_T = game:GetService("TeleportService")
				local S_H = game:GetService("HttpService")

				local File = pcall(function()
					AllIDs = S_H:JSONDecode(readfile("server-hop-temp.json"))
				end)
				if not File then
					table.insert(AllIDs, actualHour)
					pcall(function()
						writefile("server-hop-temp.json", S_H:JSONEncode(AllIDs))
					end)
				end

				local function TPReturner(placeId)
					local Site;
					if foundAnything == "" then
						Site = S_H:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"))
					else
						Site = S_H:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100&cursor=" .. foundAnything))
					end
					local ID = ""
					if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
						foundAnything = Site.nextPageCursor
					end
					local num = 0
					for i, v in pairs(Site.data) do
						local Possible = true
						ID = tostring(v.id)
						if tonumber(v.maxPlayers) > tonumber(v.playing) then
							for _, Existing in pairs(AllIDs) do
								if num ~= 0 then
									if ID == tostring(Existing) then
										Possible = false
									end
								else
									if tonumber(actualHour) ~= tonumber(Existing) then
										local delFile = pcall(function()
											delfile("server-hop-temp.json")
											AllIDs = {}
											table.insert(AllIDs, actualHour)
										end)
									end
								end
								num = num + 1
							end
							if Possible == true then
								table.insert(AllIDs, ID)
								wait()
								pcall(function()
									writefile("server-hop-temp.json", S_H:JSONEncode(AllIDs))
									wait()
									S_T:TeleportToPlaceInstance(placeId, ID, game.Players.LocalPlayer)
								end)
								wait(0.1)
								break
							end
						end
					end
				end

				while serverHopRunning do
					pcall(function()
						TPReturner(game.PlaceId)
						if foundAnything ~= "" then
							TPReturner(game.PlaceId)
						end
					end)
					task.wait(1.5)
				end
			end)

		else
			serverHopRunning = false
			if serverHopThread then
				task.cancel(serverHopThread)
				serverHopThread = nil
			end
			Rayfield:Notify({
				Title = "ServerHop",
				Content = "Disabled. You won't be automatically switched servers.",
				Duration = 3
			})
		end
	end
})

Tab_Extras:CreateToggle({
	Name = "Go Base",
	Flag = "AutoFlyToBase",
	CurrentValue = false,
	Callback = function(enabled)
		if enabled and not godEnabled then
			Rayfield:Notify({
				Title = "AutoPilot",
				Content = "Please turn on Godmode before using auto flight.",
				Duration = 4
			})
			Rayfield.Flags["AutoFlyToBase"]:Set(false)
			return
		end

		if enabled then
			local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
			if not hrp then return end

			if not miBaseDetectada then
				if detectarBasePorTexto() then
					Rayfield:Notify({
						Title = "Base found",
						Content = "Bbase with your name detected. Flying...",
						Duration = 4
					})
				else
					Rayfield:Notify({
						Title = "Your base was not detected",
						Content = "No sign was found with your name.",
						Duration = 4
					})
					Rayfield.Flags["AutoFlyToBase"]:Set(false)
					return
				end
			end

			volarAHasta(miBaseDetectada + Vector3.new(0, 5, 0))
		else
			if autopilotConnection then
				autopilotConnection:Disconnect()
				autopilotConnection = nil
				Rayfield:Notify({
					Title = "Autopilot",
					Content = "Automatic flight canceled.",
					Duration = 3
				})
			end
		end
	end
})
